% In this file you should put the actual content of the blueprint.
% It will be used both by the web and the print version.
% It should *not* include the \begin{document}
%
% If you want to split the blueprint content into several files then
% the current file can be a simple sequence of \input. Otherwise It
% can start with a \section or \chapter for instance.

\chapter{Definitions}
\label{chap:def}

\begin{definition}
    \label{def:mainVariable}
    \lean{MvPolynomial.mainVariable}
    \leanok
    The class of a multivariate polynomial $p$ is the largest variable index appearing in $p$.
\end{definition}

\begin{definition}
    \label{def:mainDegree}
    \lean{MvPolynomial.mainDegree}
    \leanok
    \uses{def:mainVariable}
    The degree of $p$ with respect to its class.
\end{definition}

\begin{definition}
    \label{def:MvPolynomial.rank}
    \lean{MvPolynomial.rank}
    \leanok
    \uses{def:mainVariable, def:mainDegree}
    The rank of a polynomial $p$ is the pair $(mainVar(p), deg(p))$ ordered lexicographically.
\end{definition}

\begin{definition}
    \label{def:reducedTo}
    \lean{MvPolynomial.reducedTo}
    \leanok
    \uses{def:mainVariable}
    $q$ is reduced with respect to $p$ if the degree of $q$ in the main variable of $p$ is strictly less than the main degree of $p$.
\end{definition}

\begin{definition}
    \label{def:reducedToSet}
    \lean{MvPolynomial.reducedToSet}
    \leanok
    \uses{def:reducedTo}
    $q$ is reduced with respect to a polynomial set $PS$ if it is reduced with respect to all elements of $PS$.
\end{definition}

\begin{definition}
    \label{def:initialOf}
    \lean{MvPolynomial.initialOf}
    \leanok
    The initial of a polynomial $p$ with respect to a variable $i$.
    It is the coefficient of the highest power of $x_i$ appearing in $p$.
\end{definition}

\begin{definition}
    \label{def:initial}
    \lean{MvPolynomial.initial}
    \leanok
    \uses{def:mainVariable, def:initialOf}
    The initial of a polynomial $p$ is the initial with respect to its class.
\end{definition}

\begin{definition}
    \label{def:initialProd}
    \lean{MvPolynomial.initialProd}
    \leanok
    \uses{def:initial}
    The product of initials of a set of polynomials.
\end{definition}

\begin{definition}
    \label{def:TriangulatedSet}
    \lean{TriangulatedSet}
    \leanok
    \uses{def:mainVariable}
    A Triangulated Set is a finite ordered sequence of non-zero polynomials with strictly increasing classes.
\end{definition}

\begin{definition}
    \label{def:TriangulatedSet.rank}
    \lean{TriangulatedSet.rank}
    \leanok
    \uses{def:TriangulatedSet, def:MvPolynomial.rank}
    The rank of a Triangulated Set is a lexicographic sequence of ranks of its polynomials.
    More intuitively, $S < T$ if one of the following two occurs:
    \begin{itemize}
        \item There exists some $k < S.length$ such that $S_0 \sim T_0, S_1 \sim T_1, ..., S_{k-1} \sim T_{k-1}$, while $S_k < T_k$.
        \item $S.length > T.length$ and $\forall i < T.length, S_i \sim T_i$.
    \end{itemize}
\end{definition}

\begin{definition}
    \label{def:takeConcat}
    \lean{TriangulatedSet.takeConcat}
    \leanok
    \uses{def:TriangulatedSet}
    "S.takeConcat p" tries to construct a new Triangulated Set by taking a prefix of $S$ and appending $p$.
    \begin{itemize}
    \item If $p$ fits naturally at the end of $S$, it behaves like "S.concat p".
    \item If $p$ conflicts with some element in $S$ (in terms of class order), "takeConcat" finds the
        first element in $S$ that has a higher or equal class than $p$, truncates $S$ before that element, and appends $p$.
    \end{itemize}
\end{definition}

\begin{definition}
    \label{def:isRemainder}
    \lean{MvPolynomial.isRemainder}
    \leanok
    \uses{def:reducedTo, def:initial}
    A remainder $r$ of $g$ by $f$ is a polynomial which is reduced with respect to $f$ and
    satisfies $init(f)^s \cdot g = q \cdot f + r$ for some $s \in \mathbb{N}$ and $q \in R[X_{\sigma}]$.
\end{definition}

\begin{definition}
    \label{def:isSetRemainder}
    \lean{MvPolynomial.isSetRemainder}
    \leanok
    \uses{def:reducedTo, def:initial}
    A remainder $r$ of $g$ by a set $S$ is a polynomial which is reduced with respect to $S$ and
    satisfies $(\prod S_i^{e_i}) \cdot g = \sum q_i \cdot S_i + r$ for some $\{e_i\}$ and $\{q_i\}$.
\end{definition}

\begin{definition}
    \label{def:pseudoOf}
    \lean{MvPolynomial.pseudoOf}
    \leanok
    \uses{def:initialOf}
    Pseudo-division of $g$ by $f$ with respect to $i$.

    Returns a triple containing the exponent, the quotient and the remainder.
\end{definition}

\begin{definition}
    \label{def:pseudo}
    \lean{MvPolynomial.pseudo}
    \leanok
    \uses{def:pseudoOf, def:mainVariable}
    Pseudo-division of $g$ by $f$ with respect to $mainVar(f)$.

    Returns a triple containing the exponent, the quotient and the remainder.
\end{definition}

\begin{definition}
    \label{def:setPseudo}
    \lean{MvPolynomial.setPseudo}
    \leanok
    \uses{def:TriangulatedSet, def:initial, def:pseudo}
    Pseudo-divides $g$ successively by elements of $S$.
    Typically, this involves dividing by $S_{l-1}$, then $S_{l-2}$, ..., down to $S_0$.

    Returns a triple containing the exponents, the quotients and the remainder.
\end{definition}

\begin{definition}
    \label{def:isAscendingSet}
    \lean{TriangulatedSet.isAscendingSet}
    \leanok
    \uses{def:TriangulatedSet, def:reducedTo}
    A Triangulated Set is an Ascending Set if every element is reduced with respect to its predecessors.
    Here "reduced" is an abstract predicate.
\end{definition}

\begin{definition}
    \label{def:isStandardAscendingSet}
    \lean{StandardAscendingSet.isAscendingSet}
    \leanok
    \uses{def:isAscendingSet}
    A Triangulated Set is a Standard Ascending Set if every element is reduced with respect to its predecessors.
\end{definition}

\begin{definition}
    \label{def:isWeakAscendingSet}
    \lean{WeakAscendingSet.isAscendingSet}
    \leanok
    \uses{def:initial, def:isAscendingSet}
    A Triangulated Set is a Weak Ascending Set if the initial of every element is reduced with respect to its predecessors.
\end{definition}

\begin{definition}
    \label{def:HasBasicSet}
    \lean{HasBasicSet}
    \leanok
    \uses{def:TriangulatedSet, def:isAscendingSet, def:reducedToSet, def:TriangulatedSet.rank}
    The interface for algorithms computing Basic Sets.
    Any instance of this class provides a "basicSet" function that computes a minimal ascending set
    contained in a given list of polynomials.
\end{definition}

\begin{definition}
    \label{def:StandardAscendingSet.basicSet}
    \lean{StandardAscendingSet.basicSet}
    \leanok
    \uses{def:TriangulatedSet, def:reducedToSet, def:TriangulatedSet.rank}
    Computes the Standard Basic Set of a list of polynomials.

    The algorithm works by:
    \begin{enumerate}
        \item Sort the list and let $BS = \emptyset$.
        \item Pick the first (minimal) element $B$ in the list.
        \item Append $B$ to the tail of the current basic set $BS$.
        \item Filter the remaining list to keep only elements reduced w.r.t. the new $BS$ and go to step 2.
    \end{enumerate}
\end{definition}

\begin{definition}
    \label{def:WeakAscendingSet.basicSet}
    \lean{WeakAscendingSet.basicSet}
    \leanok
    \uses{def:mainVariable, def:initial, def:TriangulatedSet, def:reducedToSet, def:TriangulatedSet.rank}
    Computes the Weak Basic Set of a list of polynomials.

    Difference from Standard: The filter condition includes $mainVar(p) > mainVar(B)$.
\end{definition}

\begin{definition}
    \label{def:isCharacteristicSet}
    \lean{TriangulatedSet.isCharacteristicSet}
    \leanok
    \uses{def:TriangulatedSet, def:isSetRemainder}
    $CS$ is a characteristic set of $PS$ if every polynomial in $PS$, $0$ is its remainder by $CS$, and $Zero(PS) \subseteq Zero(CS)$.
\end{definition}

\begin{definition}
    \label{def:characteristicSet}
    \lean{MvPolynomial.List.characteristicSet}
    \leanok
    \uses{def:TriangulatedSet, def:HasBasicSet, def:setPseudo, inst:TriangulatedSet.instWellFoundedLT, thm:basicSet_append_lt_of_exists_reducedToSet}
    Computes the Characteristic Set of a polynomial list $l$.

    Algorithm:
    \begin{enumerate}
        \item Set $l_0 = l$.
        \item Compute $BS = BasicSet(l)$.
        \item Compute remainders $RS$ of $l \setminus BS$ with respect to $BS$.
        \item If $RS = \emptyset$, $BS$ is the characteristic set.
        \item If not, let $l = l₀ ++ RS ++ BS$ and go to step 2.
    \end{enumerate}
    Termination is guaranteed by the well-ordering of ranks.
\end{definition}

\begin{definition}
    \label{def:zeroDecomposition}
    \lean{MvPolynomial.List.zeroDecomposition}
    \leanok
    \uses{def:characteristicSet, thm:initial_reducedToSet_of_mainVariable_ne_bot, thm:characteristicSet_isAscendingSet, thm:characteristicSet_le_basicSet}
    Decomposes the zero set of a polynomial list into a union of zero sets of triangular sets.
    The algorithm recursively computes the characteristic set $CS$
    and adds branches for the initials of $CS$.
\end{definition}

\chapter{Theorems}
\label{chap:thm}

\begin{lemma}
    \label{lem:reducedTo_of_mainVariable_lt}
    \lean{MvPolynomial.reducedTo_of_mainVariable_lt}
    \leanok
    \uses{def:mainVariable, def:reducedTo}
    $q$ is reduced w.r.t. $p$ if $mainVar(q) < mainVar(p)$.
\end{lemma}

\begin{proof}
    \leanok
    % TODO
\end{proof}

\begin{lemma}
    \label{lem:reducedTo_iff_gt_of_mainVariable_eq}
    \lean{MvPolynomial.reducedTo_iff_gt_of_mainVariable_eq}
    \leanok
    \uses{def:mainVariable, def:reducedTo, def:MvPolynomial.rank}
    If $mainVar(p) = mainVar(q)$, then $q$ is reduced with respect to $p$ if and only if $q < p$.
\end{lemma}

\begin{proof}
    \leanok
    % TODO
\end{proof}

\begin{lemma}
    \label{lem:mainVariable_lt_of_reducedTo_of_le}
    \lean{MvPolynomial.mainVariable_lt_of_reducedTo_of_le}
    \leanok
    \uses{def:mainVariable, def:reducedTo}
    $mainVar(p) < mainVar(q)$ if $p ≤ q$ and $q$ is reduced with respect to $p$.
\end{lemma}

\begin{proof}
    \leanok
    \uses{lem:reducedTo_iff_gt_of_mainVariable_eq}
    % TODO
\end{proof}

\begin{lemma}
    \label{lem:initialOf_eq_of_degreeOf_eq_zero}
    \lean{MvPolynomial.initialOf_eq_of_degreeOf_eq_zero}
    \leanok
    \uses{def:initialOf}
    $init_i(p) = p$ if $deg_i(p) = 0$ (i.e. $x_i$ does not appear in $p$).
\end{lemma}

\begin{proof}
    \leanok
    % TODO
\end{proof}

\begin{lemma}
    \label{lem:degreeOf_initialOf_self}
    \lean{MvPolynomial.degreeOf_initialOf_self}
    \leanok
    \uses{def:initialOf}
    $deg_i(init_i(p)) = 0$.
\end{lemma}

\begin{proof}
    \leanok
    % TODO
\end{proof}

\begin{lemma}
    \label{lem:initialOf_initialOf_self}
    \lean{MvPolynomial.initialOf_initialOf_self}
    \leanok
    \uses{def:initialOf}
    $init_i(init_i(p)) = init_i(p)$.
\end{lemma}

\begin{proof}
    \leanok
    \uses{lem:degreeOf_initialOf_self, lem:initialOf_eq_of_degreeOf_eq_zero}
    % TODO
\end{proof}

\begin{lemma}
    \label{lem:degreeOf_initialOf_le}
    \lean{MvPolynomial.degreeOf_initialOf_le}
    \leanok
    \uses{def:initialOf}
    $\forall i j, deg_j(init_i(p)) \le deg_j(p)$
\end{lemma}

\begin{proof}
    \leanok
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:initialOf_eq_leadingCoeff}
    \lean{MvPolynomial.initialOf_eq_leadingCoeff}
    \leanok
    \uses{def:initialOf}
    $init_i(p)$ is the leading coefficient when viewing $p$ as a univariate polynomial in $x_i$.
\end{theorem}

\begin{proof}
    \leanok
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:initialOf_decomposition}
    \lean{MvPolynomial.initialOf_decomposition}
    \leanok
    \uses{def:initialOf}
    $p = init_i(p) x_i ^ d + q$, where $deg_i(q) < d = deg_i(p)$.
\end{theorem}

\begin{proof}
    \leanok
    % TODO
\end{proof}

\begin{lemma}
    \label{lem:degreeOf_add_lt_of_initialOf_cancel}
    \lean{MvPolynomial.degreeOf_add_lt_of_initialOf_cancel}
    \leanok
    \uses{def:initialOf}
    $deg_i(p + q) < deg_i(p)$ if $deg_i(p) = deg_i(q)$ and $init_i(p) + init_i(q) = 0$.
\end{lemma}

\begin{proof}
    \leanok
    \uses{thm:initialOf_decomposition}
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:initialOf_mul_eq}
    \lean{MvPolynomial.initialOf_mul_eq}
    \leanok
    \uses{def:initialOf}
    $init_i(p \cdot q) = init_i(p) \cdot init_i(q)$ if there is no zero divisors in the coefficient ring.
\end{theorem}

\begin{proof}
    \leanok
    \uses{thm:initialOf_eq_leadingCoeff}
    % TODO
\end{proof}

\begin{lemma}
    \label{lem:mainVariable_initial_lt}
    \lean{MvPolynomial.mainVariable_initial_lt}
    \leanok
    \uses{def:mainVariable, def:initial}
    $mainVar(init(p)) < mainVar(p)$ for non-constant $p$.
\end{lemma}

\begin{proof}
    \leanok
    % TODO
\end{proof}

\begin{lemma}
    \label{lem:initial_reducedTo}
    \lean{MvPolynomial.initial_reducedTo}
    \leanok
    \uses{def:initial, def:reducedTo}
    $init_i(p)$ is reduced w.r.t. $q$ if $p$ is reduced w.r.t. to $q$.
\end{lemma}

\begin{proof}
    \leanok
    \uses{lem:degreeOf_initialOf_le}
    % TODO
\end{proof}

\begin{lemma}
    \label{lem:initial_reducedTo_self}
    \lean{MvPolynomial.initial_reducedTo_self}
    \leanok
    \uses{def:initial, def:reducedTo}
    $init_i(p)$ is reduced w.r.t. $p$ for non-constant $p$.
\end{lemma}

\begin{proof}
    \leanok
    \uses{lem:reducedTo_of_mainVariable_lt, lem:mainVariable_initial_lt}
    % TODO
\end{proof}

\begin{theorem}
    \label{inst:TriangulatedSet.instWellFoundedLT}
    \lean{TriangulatedSet.instWellFoundedLT}
    \leanok
    \uses{def:TriangulatedSet, def:TriangulatedSet.rank}
    The set of Triangulated Sets is well-founded under the lexicographic rank ordering. This guarantees the termination of the Characteristic Set Algorithm.
\end{theorem}

\begin{proof}
    \leanok
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:takeConcat_lt_of_reducedToSet}
    \lean{TriangulatedSet.takeConcat_lt_of_reducedToSet}
    \leanok
    \uses{def:takeConcat, def:reducedToSet, def:TriangulatedSet.rank}
    If $p \neq 0$ and is reduced with respect to $S$, then modifying $S$ by appending $p$ (using "takeConcat") strictly decreases the rank of $S$.
\end{theorem}

\begin{proof}
    \leanok
    \uses{lem:reducedTo_iff_gt_of_mainVariable_eq}
    % TODO
\end{proof}

\begin{lemma}
    \label{lem:degreeOf_pseudoOf_remainder_lt_of_degreeOf_ne_zero}
    \lean{MvPolynomial.degreeOf_pseudoOf_remainder_lt_of_degreeOf_ne_zero}
    \leanok
    \uses{def:pseudoOf}
    $deg_i(r) < deg_i(g)$ where $r$ is the remainder of $g$ by $f$ w.r.t. $i$ if $deg_i(f) \ne 0$.
\end{lemma}

\begin{proof}
    \leanok
    \uses{lem:degreeOf_initialOf_self, lem:initialOf_initialOf_self, lem:degreeOf_add_lt_of_initialOf_cancel, thm:initialOf_mul_eq}
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:pseudo_remainder_isRemainder}
    \lean{MvPolynomial.pseudo_remainder_isRemainder}
    \leanok
    \uses{def:isRemainder, def:pseudo}
    The remainder $r$ of $g$ by $f$ is reduced with respect to $f$ and
    satisfies $init(f)^s \cdot g = q \cdot f + r$ for some $s \in \mathbb{N}$ and $q \in R[X_{\sigma}]$.
\end{theorem}

\begin{proof}
    \leanok
    \uses{lem:degreeOf_pseudoOf_remainder_lt_of_degreeOf_ne_zero}
    % TODO
\end{proof}

\begin{lemma}
    \label{lem:degreeOf_pseudo_remainder_le_of_degreeOf_eq_zero}
    \lean{MvPolynomial.degreeOf_pseudo_remainder_le_of_degreeOf_eq_zero}
    \leanok
    \uses{def:pseudo}
    The remainder $r$ of $g$ by $f$ satisfies $deg_i(r) \le deg_i(g)$ if $deg_i(f) = 0$
\end{lemma}

\begin{proof}
    \leanok
    \uses{lem:degreeOf_initialOf_le}
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:setPseudo_remainder_isSetRemainder}
    \lean{MvPolynomial.setPseudo_remainder_isSetRemainder}
    \leanok
    \uses{def:isSetRemainder, def:setPseudo}
    The remainder $r$ of $g$ by a set $S$ is reduced with respect to $S$ and
    satisfies $(\prod S_i^{e_i}) \cdot g = \sum q_i \cdot S_i + r$ for some $\{e_i\}$ and $\{q_i\}$.
\end{theorem}

\begin{proof}
    \leanok
    \uses{thm:pseudo_remainder_isRemainder, lem:degreeOf_pseudo_remainder_le_of_degreeOf_eq_zero}
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:pseudo_remainder_eq_zero_of_dvd}
    \lean{MvPolynomial.pseudo_remainder_eq_zero_of_dvd}
    \leanok
    \uses{def:pseudo}
    The remainder of $g$ by $f$ is $0$ if $f$ is a divisor of $g$.
\end{theorem}

\begin{proof}
    \leanok
    \uses{lem:degreeOf_pseudoOf_remainder_lt_of_degreeOf_ne_zero}
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:pseudo_remainder_eq_of_degreeOf_eq_zero}
    \lean{MvPolynomial.pseudo_remainder_eq_of_degreeOf_eq_zero}
    \leanok
    \uses{def:pseudo}
    The remainder of $g$ by $f$ is $g$ if $deg_c(g) = 0$ where $c = mainVar(f)$.
\end{theorem}

\begin{proof}
    \leanok
    \uses{thm:pseudo_remainder_eq_zero_of_dvd}
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:setPseudo_remainder_eq_zero_of_mem}
    \lean{MvPolynomial.setPseudo_remainder_eq_zero_of_mem}
    \leanok
    \uses{def:setPseudo}
    The remainder of $p$ by a set $S$ is $0$ if $p$ is in $S$.
\end{theorem}

\begin{proof}
    \leanok
    \uses{thm:pseudo_remainder_eq_zero_of_dvd, thm:pseudo_remainder_eq_of_degreeOf_eq_zero}
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:initial_reducedToSet_of_mainVariable_ne_bot}
    \lean{AscendingSet.initial_reducedToSet_of_mainVariable_ne_bot}
    \leanok
    \uses{def:initial, def:reducedToSet, def:mainVariable, def:isAscendingSet}
    If $p$ is in $S$ and $mainVar(p) \neq \bot$, then $init(p)$ is in $S$.
\end{theorem}

\begin{proof}
    \leanok
    \uses{lem:initial_reducedTo, lem:initial_reducedTo_self}
    % TODO
\end{proof}

\begin{theorem}
    \label{inst:StandardAscendingSet.instHasBasicSet}
    \lean{StandardAscendingSet.instHasBasicSet}
    \leanok
    \uses{def:isStandardAscendingSet, def:HasBasicSet, def:StandardAscendingSet.basicSet}
    The algorithm computes a minimal standard ascending set contained in the input list.
\end{theorem}

\begin{proof}
    \leanok
    \uses{lem:mainVariable_lt_of_reducedTo_of_le, thm:takeConcat_lt_of_reducedToSet}
    % TODO
\end{proof}

\begin{theorem}
    \label{inst:WeakAscendingSet.instHasBasicSet}
    \lean{WeakAscendingSet.instHasBasicSet}
    \leanok
    \uses{def:isWeakAscendingSet, def:HasBasicSet, def:WeakAscendingSet.basicSet}
    The algorithm computes a minimal weak ascending set contained in the input list.
\end{theorem}

\begin{proof}
    \leanok
    \uses{thm:takeConcat_lt_of_reducedToSet}
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:basicSet_append_lt_of_exists_reducedToSet}
    \lean{MvPolynomial.List.basicSet_append_lt_of_exists_reducedToSet}
    \leanok
    \uses{def:HasBasicSet}
    Appending an element which is reduced w.r.t. the basic set of list strictly decreases the rank.
    Crucial for proving termination of characteristic set and zero decomposition algorithms.
\end{theorem}

\begin{proof}
    \leanok
    \uses{thm:takeConcat_lt_of_reducedToSet}
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:vanishingSet_diff_initialProd_subset}
    \lean{CharacteristicSet.vanishingSet_diff_initialProd_subset}
    \leanok
    \uses{def:TriangulatedSet, def:isSetRemainder, def:initialProd}
    Well-ordering principle (1):
    $Zero(CS/IP) \subseteq Zero(PS)$, where $IP$ is the initial-product of $CS$.
\end{theorem}

\begin{proof}
    \leanok
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:vanishingSet_diff_initialProd_eq}
    \lean{CharacteristicSet.vanishingSet_diff_initialProd_eq}
    \leanok
    \uses{def:TriangulatedSet, def:isCharacteristicSet, def:initialProd}
    Well-ordering principle (2):
    $Zero(CS/IP) = Zero(PS/IP)$, where $IP$ is the initial-product of $CS$.
\end{theorem}

\begin{proof}
    \leanok
    \uses{thm:vanishingSet_diff_initialProd_subset}
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:vanishingSet_decomposition}
    \lean{CharacteristicSet.vanishingSet_decomposition}
    \leanok
    \uses{def:TriangulatedSet, def:isCharacteristicSet, def:initialProd}
    Well-ordering principle (3):
    $$ Zero(PS) = Zero(CS/IP) \cup \left(\bigcup_{p \in CS} Zero(PS \cup {init(p)})\right) $$.
\end{theorem}

\begin{proof}
    \leanok
    \uses{thm:vanishingSet_diff_initialProd_eq}
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:characteristicSet_isCharacteristicSet}
    \lean{MvPolynomial.List.characteristicSet_isCharacteristicSet}
    \leanok
    \uses{def:characteristicSet, def:isCharacteristicSet}
    The algorithm computes a valid characteristic set for the input list.
\end{theorem}

\begin{proof}
    \leanok
    \uses{thm:setPseudo_remainder_isSetRemainder, thm:setPseudo_remainder_eq_zero_of_mem}
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:characteristicSet_isAscendingSet}
    \lean{MvPolynomial.List.characteristicSet_isAscendingSet}
    \leanok
    \uses{def:characteristicSet, def:isAscendingSet}
    The computed characteristic set is an ascending set.
\end{theorem}

\begin{proof}
    \leanok
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:characteristicSet_le_basicSet}
    \lean{MvPolynomial.List.characteristicSet_le_basicSet}
    \leanok
    \uses{def:characteristicSet, def:TriangulatedSet.rank, def:HasBasicSet}
    The rank of computed characteristic set $\le$ the rank of the input list.
\end{theorem}

\begin{proof}
    \leanok
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:zero_isSetRemainder_of_mem_zeroDecomposition}
    \lean{MvPolynomial.List.zero_isSetRemainder_of_mem_zeroDecomposition}
    \leanok
    \uses{def:zeroDecomposition}
    $\forall CS \in \mathcal{ZD}(PS), g \in PS$, $0$ is the remainder of $g$ by $CS$.
\end{theorem}

\begin{proof}
    \leanok
    \uses{thm:characteristicSet_isCharacteristicSet}
    % TODO
\end{proof}

\begin{theorem}
    \label{thm:vanishingSet_eq_zeroDecomposition_union}
    \lean{MvPolynomial.List.vanishingSet_eq_zeroDecomposition_union}
    \leanok
    \uses{def:isCharacteristicSet, def:zeroDecomposition}
    \textbf{Zero Decomposition Theorem}:
    The zero set of a polynomial system $PS$ is the union of the zero sets of the triangular systems computed by the algorithm:
    $$ Zero(PS) = \bigcup_{CS \in \mathcal{ZD}(PS)} Zero(CS/IP(CS)) $$.
\end{theorem}

\begin{proof}
    \leanok
    \uses{thm:characteristicSet_isCharacteristicSet, thm:vanishingSet_decomposition, inst:TriangulatedSet.instWellFoundedLT}
    % TODO
\end{proof}
